# 富文本编辑器 — 设计文档

## 技术选型决策

### 为什么是 UITextView + UIViewRepresentable

| 方案 | 结论 | 原因 |
|------|------|------|
| SwiftUI `TextEditor` | 否决 | 不支持 `NSAttributedString`，无法实现格式操作 |
| WKWebView + contentEditable | 否决 | JS ↔ Native 通信延迟高，撤销栈管理复杂，调试成本大 |
| UITextView 子类 + UIViewRepresentable | 采用 | 直接操作 `NSTextStorage`，与 Android `Spannable` 模型对等；`NSLayoutManager` 可自定义绘制段落装饰 |

核心判断：Android Knife 的本质是 `EditText` + `Spannable` 的属性操作。iOS 的 `UITextView` + `NSTextStorage` 是最直接的对等物，概念映射成本最低。

---

## 架构分层

```
┌─────────────────────────────────────────────────────┐
│  Layer 5: 序列化层                                    │
│  HTMLParser / HTMLSerializer                         │
│  HTML ↔ NSAttributedString 双向转换                   │
└──────────────────────┬──────────────────────────────┘
                       │ NSAttributedString
┌──────────────────────┴──────────────────────────────┐
│  Layer 4: SwiftUI 桥接层                              │
│  RichTextEditor (UIViewRepresentable)                │
│  RichTextCoordinator (UITextViewDelegate)            │
└──────────────────────┬──────────────────────────────┘
                       │ UIKit 事件 / Binding 同步
┌──────────────────────┴──────────────────────────────┐
│  Layer 3: 编辑器核心层                                 │
│  RichTextEditorView (UITextView 子类)                 │
│  RichTextToolbar (inputAccessoryView)                │
└──────────────────────┬──────────────────────────────┘
                       │ NSTextStorage 属性操作
┌──────────────────────┴──────────────────────────────┐
│  Layer 2: 渲染层                                      │
│  RichTextLayoutManager (NSLayoutManager 子类)         │
└──────────────────────┬──────────────────────────────┘
                       │ 自定义属性键
┌──────────────────────┴──────────────────────────────┐
│  Layer 1: 格式定义层                                   │
│  RichTextFormat (枚举) + NSAttributedString.Key 扩展   │
│  HighlightColors (色值映射)                            │
└─────────────────────────────────────────────────────┘
```

---

## 文件职责与依赖

| 文件 | 行数 | 职责 | 依赖 |
|------|------|------|------|
| `RichTextFormat.swift` | 27 | 8 种格式枚举 + 3 个自定义 `NSAttributedString.Key`（`.bulletList` / `.blockquote` / `.highlightColor`） | 无 |
| `HighlightColors.swift` | 90 | 13 组 light↔dark ARGB 映射表；`UInt32 ↔ UIColor` 转换；Android `Int32` 互转 | 无 |
| `RichTextEditorView.swift` | 358 | `UITextView` 子类，实现 `applyFormat` / `removeFormat` / `containsFormat` 三件套；段落级行范围计算 | `RichTextFormat`、`HighlightColors`、`RichTextLayoutManager` |
| `RichTextLayoutManager.swift` | 78 | `NSLayoutManager` 子类，`drawBackground` 中绘制 bullet 圆点和 blockquote 色条 | `RichTextFormat`（自定义属性键） |
| `RichTextCoordinator.swift` | 65 | `UITextViewDelegate` 实现，将 UIKit 事件转发为 SwiftUI 状态更新 | `RichTextEditor`、`RichTextEditorView`、`HighlightColors` |
| `RichTextEditor.swift` | 56 | `UIViewRepresentable` 入口，管理 `Binding<NSAttributedString>` 和 `Binding<Set<RichTextFormat>>` | `RichTextEditorView`、`RichTextCoordinator`、`RichTextToolbar` |
| `HTMLParser.swift` | 273 | `XMLParser` SAX 模式解析 HTML → `NSAttributedString` | `RichTextFormat`、`HighlightColors` |
| `HTMLSerializer.swift` | 276 | `NSAttributedString` → HTML 字符串，逐行扫描段落级属性后逐 run 输出字符级标签 | `HighlightColors` |
| `RichTextToolbar.swift` | 241 | `UIView` 子类，水平滚动按钮栏，通过闭包回调格式操作 | `RichTextFormat` |

依赖关系图（箭头表示"依赖"）：

```
RichTextEditor ──→ RichTextEditorView ──→ RichTextLayoutManager
      │                    │                       │
      │                    ▼                       │
      │              HighlightColors ◄─────────────┘
      │                    ▲
      ▼                    │
RichTextCoordinator        │
      │                    │
      ▼                    │
RichTextToolbar      RichTextFormat ◄── HTMLParser
                           ▲                │
                           │                ▼
                     HTMLSerializer ──→ HighlightColors
```

---

## 核心机制详解

### 1. 格式操作三件套与 Knife KnifePart 的对应

Android Knife 的格式操作核心是 `KnifePart` 分割逻辑：对选区内的 Span 做 split/merge。iOS 端利用 `NSTextStorage` 的属性枚举天然支持范围级操作，无需手动分割。

对应关系：

| Android Knife | iOS 实现 | 说明 |
|---------------|----------|------|
| `styleValid(style, start, end)` | `applyStyle(.bold/.italic, in:)` | 枚举 `.font` 属性，`insert` trait |
| `styleInvalid(style, start, end)` | `removeStyle(.bold/.italic, in:)` | 枚举 `.font` 属性，`remove` trait |
| `containStyle(style, start, end)` | `containsStyle(.bold/.italic, in:)` | 枚举检查所有子范围是否都包含 trait |
| `underlineValid` / `strikethroughValid` | `applyCharacterAttribute(_:value:in:)` | `textStorage.addAttribute` |
| `underlineInvalid` / `strikethroughInvalid` | `removeCharacterAttribute(_:in:)` | `textStorage.removeAttribute` |
| `bulletValid` / `quoteValid` | `applyParagraphFormat(_:in:)` | 按行范围添加自定义属性 + 缩进段落样式 |
| `bulletInvalid` / `quoteInvalid` | `removeParagraphFormat(_:in:)` | 移除自定义属性，恢复默认段落样式 |

光标位置（零宽选区）的格式检测：检查光标前后各一个字符的属性，两者都包含该格式才返回 `true`。这与 Android Knife 的 `containStyle` 在零宽选区时的行为一致。

### 2. 段落级格式：自定义属性键 + NSLayoutManager 绘制

iOS `NSAttributedString` 没有 Android `BulletSpan` / `QuoteSpan` 的直接对等物。解决方案：

1. 定义自定义属性键 `.bulletList` 和 `.blockquote`（布尔值标记）
2. 应用时同时设置 `NSParagraphStyle` 的 `headIndent` / `firstLineHeadIndent` 为 16pt，为装饰元素留出空间
3. `RichTextLayoutManager.drawBackground` 中枚举这两个自定义属性，在缩进区域绘制：
   - Bullet：段落首行左侧绘制实心圆点（半径 3pt），对标 `KnifeBulletSpan.drawLeadingMargin`
   - Blockquote：每行左侧绘制绿色竖条（宽 2pt），对标 `KnifeQuoteSpan.drawLeadingMargin`

TextKit 栈初始化链：`NSTextStorage` → `RichTextLayoutManager` → `NSTextContainer` → `UITextView(frame:textContainer:)`。必须在 `init` 中手动组装，不能使用 `UITextView()` 默认初始化器。

### 3. 高亮色跨平台一致性方案

核心决策：存储层始终使用 light mode 原始 ARGB 值，显示层根据当前 `userInterfaceStyle` 动态适配。

```
存储（HTML / SQLite）          显示（UITextView）
     │                              ▲
     │  light ARGB UInt32           │  UIColor
     ▼                              │
 .highlightColor 属性 ──────→ HighlightColors.adaptedColor()
                                    │
                              lightToDark 查表
                              dark mode → 对应暗色
                              light mode → 原值直出
```

序列化路径（`HTMLSerializer`）：
1. 优先读取 `.highlightColor` 自定义属性（light mode 原始值）
2. 若不存在，从 `.backgroundColor` 的 `UIColor` 反推：先转 ARGB，再通过 `darkToLight` 映射还原
3. 最终通过 `Int32(bitPattern:)` 转为 Android 有符号整数写入 HTML

### 4. HTML 解析选型

| 方案 | 结论 | 原因 |
|------|------|------|
| `NSAttributedString(data:options:[.documentType: .html])` | 否决 | 内部调用 WebKit，必须在主线程执行，性能差且不可控 |
| `XMLParser` SAX 模式 | 采用 | 轻量、无 WebKit 依赖、可精确控制属性映射 |

预处理步骤（`parseHTML` 方法）：
1. 清除 `&zwj;` 前缀
2. `<br>` / `<br/>` / `<br />` → `\n`
3. 包裹 `<root>` 使其成为合法 XML
4. `&nbsp;` → `\u{00A0}`（XMLParser 不认识 HTML 命名实体，只认 `&amp;` `&lt;` `&gt;` `&apos;` `&quot;`）

Android 有符号 Int32 色值转换：`UInt32(bitPattern: Int32(valueStr))`。例如 `-394337` → `0xFFF9E79F`。

### 5. SwiftUI ↔ UIKit 桥接数据流

```
SwiftUI 侧                          UIKit 侧
─────────────                        ─────────
@Binding attributedText  ◄──────── textViewDidChange
                         ────────► updateUIView (外部驱动时同步)

@Binding activeFormats   ◄──────── textViewDidChangeSelection
                         ────────► updateUIView → toolbar.updateActiveFormats

onTextChange 闭包        ◄──────── textViewDidChange

工具栏按钮点击            ────────► coordinator.handleToolbarAction
                                       → editorView.toggleFormat
                                       → updateActiveFormats
```

关键防护：`updateUIView` 中通过 `editorView.attributedText != attributedText` 判断是否为外部驱动变更，避免 Coordinator 写入 → `updateUIView` 回写 → 再触发 `textViewDidChange` 的循环更新。

---

## Android ↔ iOS 技术映射

| Android Knife | iOS 实现 | 文件 |
|---------------|----------|------|
| `KnifeText extends EditText` | `RichTextEditorView: UITextView` | `RichTextEditorView.swift` |
| `Spannable` 属性操作 | `NSTextStorage` 属性操作 | `RichTextEditorView.swift` |
| `KnifePart` 范围分割 | `enumerateAttribute(_:in:)` 自动分割 | `RichTextEditorView.swift` |
| `KnifeBulletSpan.drawLeadingMargin` | `RichTextLayoutManager.drawBullet` | `RichTextLayoutManager.swift` |
| `KnifeQuoteSpan.drawLeadingMargin` | `RichTextLayoutManager.drawQuoteStripe` | `RichTextLayoutManager.swift` |
| `KnifeParser.fromHtml` + `KnifeTagHandler` | `HTMLParser`（XMLParser SAX） | `HTMLParser.swift` |
| `KnifeParser.toHtml` + `KnifeParser.withinHtml/withinParagraph/withinStyle` | `HTMLSerializer.serialize` + 同名私有方法 | `HTMLSerializer.swift` |
| `TextWatcher` | `RichTextCoordinator: UITextViewDelegate` | `RichTextCoordinator.swift` |
| `Constant.HIGHLIGHT_COLORS` | `HighlightColors.lightToDark` | `HighlightColors.swift` |
| `Color.parseColor` / `Int` 色值 | `HighlightColors.argbFromAndroidInt` / `androidInt(from:)` | `HighlightColors.swift` |

---

## 已知限制与后续演进

| 限制 | 说明 | 演进方向 |
|------|------|---------|
| 高亮色选择器缺失 | 当前 toggle highlight 使用默认色（`#F9E79F`），未提供 13 色选择 UI | 工具栏 highlight 按钮长按弹出色板 |
| 链接编辑 UI 缺失 | `applyLink` 接口已实现，但工具栏 link 按钮未接入 URL 输入弹窗 | 弹出 `UIAlertController` 或自定义输入面板 |
| 段落格式不支持嵌套 | bullet 内不能嵌套 blockquote，与 Android 行为一致 | 无需改变 |
| 无图片支持 | Android 端同样不支持，不属于迁移范围 | 如需支持，需扩展 `NSTextAttachment` |
| TextKit 1 | 当前使用 TextKit 1（`NSLayoutManager`），未迁移至 TextKit 2 | iOS 18+ 可考虑迁移，但 TextKit 2 对自定义绘制的支持仍有限 |
